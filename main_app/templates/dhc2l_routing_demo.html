<!DOCTYPE html>
<html>
<head>
    <title>D-HC2L Dynamic Routing on Google Maps</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 10px; }
        #map { height: 70vh; width: 100%; border: 1px solid #ccc; }
        .controls { margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 5px; }
        .control-group { display: inline-block; margin-right: 15px; vertical-align: top; }
        button { padding: 8px 15px; margin: 3px; cursor: pointer; border: none; border-radius: 3px; }
        .btn-primary { background: #007cba; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffc107; color: black; }
        .info-panel { margin: 10px 0; padding: 10px; background: #e9ecef; border-radius: 5px; }
        .route-info { display: none; margin: 10px 0; padding: 15px; background: #d4edda; border-radius: 5px; border-left: 5px solid #28a745; }
        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0; }
        .metric-box { padding: 10px; text-align: center; background: white; border-radius: 5px; border: 1px solid #ddd; }
        .metric-value { font-size: 24px; font-weight: bold; color: #007cba; }
        .metric-label { font-size: 12px; color: #666; margin-top: 5px; }
        .coordinates-input { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0; }
        .coord-input { padding: 5px; border: 1px solid #ddd; border-radius: 3px; }
        .loading { display: none; text-align: center; padding: 20px; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .error-message { background: #f8d7da; color: #721c24; padding: 10px; border-radius: 5px; margin: 10px 0; border: 1px solid #f5c6cb; }
        .legend { background: white; padding: 10px; border-radius: 5px; border: 1px solid #ddd; margin: 10px 0; }
        .legend-item { display: inline-block; margin-right: 15px; }
        .color-box { display: inline-block; width: 20px; height: 3px; margin-right: 5px; vertical-align: middle; }
    </style>
</head>
<body>
    <h1>üöó D-HC2L Dynamic Routing System</h1>
    <p>Click two points on the map to compute optimal routes using the D-HC2L algorithm with traffic disruption avoidance.</p>
    
    <div class="controls">
        <div class="control-group">
            <h4>üéØ Route Planning</h4>
            <button class="btn-primary" onclick="enableRouteMode()">Select Route Points</button>
            <button class="btn-success" onclick="computeRoute()" id="computeBtn" disabled>Compute Base Route</button>
            <button class="btn-warning" onclick="computeDisruptedRoute()" id="computeDisruptedBtn" disabled>Compute Disrupted Route</button>
            <button class="btn-secondary" onclick="compareRoutes()" id="compareBtn" disabled>Compare Routes</button>
            <button class="btn-danger" onclick="clearRoute()">Clear Route</button>
        </div>
        
        <div class="control-group">
            <h4>üìç Manual Coordinates</h4>
            <div class="coordinates-input">
                <input type="number" class="coord-input" id="startLat" placeholder="Start Latitude" step="0.000001">
                <input type="number" class="coord-input" id="startLng" placeholder="Start Longitude" step="0.000001">
                <input type="number" class="coord-input" id="destLat" placeholder="Dest Latitude" step="0.000001">
                <input type="number" class="coord-input" id="destLng" placeholder="Dest Longitude" step="0.000001">
            </div>
            <button class="btn-success" onclick="enablePinStartMode()">üìç Pin Start Point</button>
            <button class="btn-danger" onclick="enablePinDestMode()">üìç Pin Destination</button>
            <button class="btn-primary" onclick="computeRouteFromInputs()">Compute from Inputs</button>
            <button class="btn-secondary" onclick="useQuezOnCityDefaults()">Use QC Defaults</button>
        </div>
        
        <div class="control-group">
            <h4>üó∫Ô∏è Map Data</h4>
            <button class="btn-primary" onclick="loadAllNodes()">Load All Nodes</button>
            <button class="btn-secondary" onclick="loadTrafficData()">Load Traffic Data</button>
            <button class="btn-danger" onclick="clearAll()">Clear All</button>
        </div>
    </div>
    
    <div class="legend" id="routeLegend" style="display: none;">
        <h4>Route Legend</h4>
        <div class="legend-item">
            <span class="color-box" style="background: #FF0000;"></span>
            D-HC2L Optimal Route
        </div>
        <div class="legend-item">
            <span class="color-box" style="background: #00FF00;"></span>
            Straight Line Distance
        </div>
        <div class="legend-item">
            <span class="color-box" style="background: #0000FF;"></span>
            Road Network
        </div>
        <div class="legend-item">
            <span class="color-box" style="background: #FFA500;"></span>
            Traffic Disruptions
        </div>
    </div>
    
    <div class="loading" id="loadingIndicator">
        <div class="spinner"></div>
        <p>Computing optimal route using D-HC2L algorithm...</p>
    </div>
    
    <div id="errorContainer"></div>
    
    <div class="info-panel" id="instructionPanel">
        <strong>Instructions:</strong>
        <ol>
            <li>Click "Select Route Points" to enable point selection mode</li>
            <li>Click on the map to set your start point (green marker)</li>
            <li>Click on the map again to set your destination (red marker)</li>
            <li>Click "Compute D-HC2L Route" to find the optimal path</li>
            <li>View routing metrics and performance data below</li>
            <li>Use "Compare Routes" to see different routing approaches</li>
        </ol>
        <strong>Features:</strong> Real-time traffic awareness ‚Ä¢ Disruption avoidance ‚Ä¢ Performance metrics ‚Ä¢ Multi-algorithm comparison
    </div>
    
    <div id="map"></div>
    
    <div id="routeInfo" class="route-info">
        <h3>üìä D-HC2L Route Analysis</h3>
        <div id="routeMetrics" class="metrics-grid"></div>
        <div id="routeDetails"></div>
    </div>

    <script>
        let map;
        let routeMode = false;
        let pinStartMode = false;
        let pinDestMode = false;
        let startMarker = null;
        let endMarker = null;
        let startCoords = null;
        let endCoords = null;
        let routePolylines = [];
        let nodeMarkers = [];
        let trafficPolylines = [];
        
        function initMap() {
            // Center on Quezon City
            map = new google.maps.Map(document.getElementById('map'), {
                zoom: 13,
                center: {lat: 14.6760, lng: 121.0437},
                mapTypeId: 'roadmap'
            });
            
            // Click listener for route planning and pin modes
            map.addListener('click', function(event) {
                if (routeMode) {
                    handleMapClick(event.latLng.lat(), event.latLng.lng());
                } else if (pinStartMode) {
                    handlePinStartClick(event.latLng.lat(), event.latLng.lng());
                } else if (pinDestMode) {
                    handlePinDestClick(event.latLng.lat(), event.latLng.lng());
                }
            });
            
            console.log('D-HC2L Map initialized. Click "Select Route Points" to start planning.');
        }
        
        function enableRouteMode() {
            routeMode = true;
            startCoords = null;
            endCoords = null;
            clearMarkers();
            
            document.getElementById('instructionPanel').innerHTML = `
                <strong>Route Selection Mode Active</strong><br>
                <span style="color: green;">üìç Step 1:</span> Click on the map to set your <strong>start point</strong><br>
                <span style="color: red;">üìç Step 2:</span> Click on the map to set your <strong>destination</strong><br>
                <span style="color: blue;">üîÑ Step 3:</span> Click "Compute D-HC2L Route" to find optimal path
            `;
            
            map.setOptions({cursor: 'crosshair'});
            console.log('Route selection mode enabled. Click on map to set start and destination.');
        }
        
        function handleMapClick(lat, lng) {
            if (!startCoords) {
                // Set start point
                startCoords = {lat: lat, lng: lng};
                
                if (startMarker) startMarker.setMap(null);
                startMarker = new google.maps.Marker({
                    position: {lat: lat, lng: lng},
                    map: map,
                    title: 'Start Point',
                    icon: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png'
                });
                
                // Update input fields
                document.getElementById('startLat').value = lat.toFixed(6);
                document.getElementById('startLng').value = lng.toFixed(6);
                
                console.log(`Start point set: ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
                
            } else if (!endCoords) {
                // Set end point
                endCoords = {lat: lat, lng: lng};
                
                if (endMarker) endMarker.setMap(null);
                endMarker = new google.maps.Marker({
                    position: {lat: lat, lng: lng},
                    map: map,
                    title: 'Destination',
                    icon: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png'
                });
                
                // Update input fields
                document.getElementById('destLat').value = lat.toFixed(6);
                document.getElementById('destLng').value = lng.toFixed(6);
                
                // Enable compute button
                document.getElementById('computeBtn').disabled = false;
                document.getElementById('computeDisruptedBtn').disabled = false;
                document.getElementById('compareBtn').disabled = false;
                
                // Update instructions
                document.getElementById('instructionPanel').innerHTML = `
                    <strong>‚úÖ Route Points Selected</strong><br>
                    üü¢ Start: ${startCoords.lat.toFixed(6)}, ${startCoords.lng.toFixed(6)}<br>
                    üî¥ Destination: ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                    <strong>Ready to compute optimal route using D-HC2L algorithm!</strong>
                `;
                
                routeMode = false;
                map.setOptions({cursor: 'default'});
                
                console.log(`Destination set: ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
                console.log('Ready to compute route!');
            }
        }
        
        function enablePinStartMode() {
            // Disable other modes
            routeMode = false;
            pinDestMode = false;
            pinStartMode = true;
            
            document.getElementById('instructionPanel').innerHTML = `
                <strong>üìç Pin Start Point Mode Active</strong><br>
                <span style="color: green;">Click anywhere on the map to pin your starting point</span><br>
                The coordinates will be automatically filled in the input fields.
            `;
            
            map.setOptions({cursor: 'crosshair'});
            console.log('Pin start point mode enabled. Click on map to set start point.');
        }
        
        function enablePinDestMode() {
            // Disable other modes
            routeMode = false;
            pinStartMode = false;
            pinDestMode = true;
            
            document.getElementById('instructionPanel').innerHTML = `
                <strong>üìç Pin Destination Point Mode Active</strong><br>
                <span style="color: red;">Click anywhere on the map to pin your destination point</span><br>
                The coordinates will be automatically filled in the input fields.
            `;
            
            map.setOptions({cursor: 'crosshair'});
            console.log('Pin destination point mode enabled. Click on map to set destination.');
        }
        
        function handlePinStartClick(lat, lng) {
            // Set start point
            startCoords = {lat: lat, lng: lng};
            
            if (startMarker) startMarker.setMap(null);
            startMarker = new google.maps.Marker({
                position: {lat: lat, lng: lng},
                map: map,
                title: 'Start Point',
                icon: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png'
            });
            
            // Update input fields
            document.getElementById('startLat').value = lat.toFixed(6);
            document.getElementById('startLng').value = lng.toFixed(6);
            
            // Exit pin mode
            pinStartMode = false;
            map.setOptions({cursor: 'default'});
            
            // Update instructions
            document.getElementById('instructionPanel').innerHTML = `
                <strong>‚úÖ Start Point Pinned</strong><br>
                üü¢ Start: ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                You can now pin a destination point or use manual coordinates to compute a route.
            `;
            
            // Enable compute button if both points are set
            if (startCoords && endCoords) {
                document.getElementById('computeBtn').disabled = false;
                document.getElementById('computeDisruptedBtn').disabled = false;
                document.getElementById('compareBtn').disabled = false;
            }
            
            console.log(`Start point pinned: ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
        }
        
        function handlePinDestClick(lat, lng) {
            // Set destination point
            endCoords = {lat: lat, lng: lng};
            
            if (endMarker) endMarker.setMap(null);
            endMarker = new google.maps.Marker({
                position: {lat: lat, lng: lng},
                map: map,
                title: 'Destination',
                icon: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png'
            });
            
            // Update input fields
            document.getElementById('destLat').value = lat.toFixed(6);
            document.getElementById('destLng').value = lng.toFixed(6);
            
            // Exit pin mode
            pinDestMode = false;
            map.setOptions({cursor: 'default'});
            
            // Update instructions
            document.getElementById('instructionPanel').innerHTML = `
                <strong>‚úÖ Destination Point Pinned</strong><br>
                üî¥ Destination: ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
                You can now pin a start point or use manual coordinates to compute a route.
            `;
            
            // Enable compute button if both points are set
            if (startCoords && endCoords) {
                document.getElementById('computeBtn').disabled = false;
                document.getElementById('computeDisruptedBtn').disabled = false;
                document.getElementById('compareBtn').disabled = false;
            }
            
            console.log(`Destination point pinned: ${lat.toFixed(6)}, ${lng.toFixed(6)}`);
        }
        
        async function computeDisruptedRoute() {
            if (!startCoords || !endCoords) {
                alert('Please select start and destination points first.');
                return;
            }
            
            showLoading(true);
            clearRoute(false); // Clear previous route but keep markers
            
            try {
                const response = await fetch('/compute_dhc2l_route', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        start_lat: startCoords.lat,
                        start_lng: startCoords.lng,
                        dest_lat: endCoords.lat,
                        dest_lng: endCoords.lng,
                        use_disruptions: true  // Enable disrupted mode
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displayRoute(result);
                    showRouteMetrics(result.metrics);
                    showRouteDetails(result);
                    console.log('‚úÖ GPS HC2L disrupted route computed successfully!');
                } else {
                    showError(`Disrupted route computation failed: ${result.error}`);
                }
                
            } catch (error) {
                showError(`Network error: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }
        
        async function computeRoute() {
            if (!startCoords || !endCoords) {
                alert('Please select start and destination points first.');
                return;
            }
            
            showLoading(true);
            clearRoute(false); // Clear previous route but keep markers
            
            try {
                const response = await fetch('/compute_dhc2l_route', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        start_lat: startCoords.lat,
                        start_lng: startCoords.lng,
                        dest_lat: endCoords.lat,
                        dest_lng: endCoords.lng,
                        use_disruptions: false  // Default to base mode
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displayRoute(result);
                    showRouteMetrics(result.metrics);
                    showRouteDetails(result);
                    console.log('‚úÖ GPS HC2L route computed successfully!');
                } else {
                    showError(`Route computation failed: ${result.error}`);
                }
                
            } catch (error) {
                showError(`Network error: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }
        
        async function computeRouteFromInputs() {
            const startLat = parseFloat(document.getElementById('startLat').value);
            const startLng = parseFloat(document.getElementById('startLng').value);
            const destLat = parseFloat(document.getElementById('destLat').value);
            const destLng = parseFloat(document.getElementById('destLng').value);
            
            if (isNaN(startLat) || isNaN(startLng) || isNaN(destLat) || isNaN(destLng)) {
                alert('Please enter valid coordinates.');
                return;
            }
            
            // Set coordinates and markers
            startCoords = {lat: startLat, lng: startLng};
            endCoords = {lat: destLat, lng: destLng};
            
            clearMarkers();
            
            startMarker = new google.maps.Marker({
                position: startCoords,
                map: map,
                title: 'Start Point',
                icon: 'http://maps.google.com/mapfiles/ms/icons/green-dot.png'
            });
            
            endMarker = new google.maps.Marker({
                position: endCoords,
                map: map,
                title: 'Destination',
                icon: 'http://maps.google.com/mapfiles/ms/icons/red-dot.png'
            });
            
            // Fit map to show both points
            const bounds = new google.maps.LatLngBounds();
            bounds.extend(startCoords);
            bounds.extend(endCoords);
            map.fitBounds(bounds);
            
            // Enable buttons
            document.getElementById('computeBtn').disabled = false;
            document.getElementById('computeDisruptedBtn').disabled = false;
            document.getElementById('compareBtn').disabled = false;
            
            // Compute route
            await computeRoute();
        }
        
        function useQuezOnCityDefaults() {
            // Set default Quezon City coordinates
            document.getElementById('startLat').value = '14.650000';
            document.getElementById('startLng').value = '121.050000';
            document.getElementById('destLat').value = '14.700000';
            document.getElementById('destLng').value = '121.100000';
            
            computeRouteFromInputs();
        }
        
        async function compareRoutes() {
            if (!startCoords || !endCoords) {
                alert('Please select start and destination points first.');
                return;
            }
            
            showLoading(true);
            clearRoute(false);
            
            try {
                const response = await fetch('/compare_routes', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        start_lat: startCoords.lat,
                        start_lng: startCoords.lng,
                        dest_lat: endCoords.lat,
                        dest_lng: endCoords.lng
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displayRouteComparison(result);
                    console.log('‚úÖ Route comparison completed!');
                } else {
                    showError(`Route comparison failed: ${result.error}`);
                }
                
            } catch (error) {
                showError(`Network error: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }
        
        function displayRoute(routeData) {
            clearRoute(false);
            
            // Display route polylines
            routeData.route.polylines.forEach(polyline => {
                const mapPolyline = new google.maps.Polyline({
                    path: polyline.path,
                    geodesic: polyline.geodesic,
                    strokeColor: polyline.strokeColor,
                    strokeOpacity: polyline.strokeOpacity,
                    strokeWeight: polyline.strokeWeight,
                    map: map
                });
                
                routePolylines.push(mapPolyline);
            });
            
            // Fit map to show route
            if (routeData.route.polylines.length > 0) {
                const bounds = new google.maps.LatLngBounds();
                routeData.route.polylines[0].path.forEach(point => {
                    bounds.extend(point);
                });
                map.fitBounds(bounds);
            }
            
            // Show legend
            document.getElementById('routeLegend').style.display = 'block';
            document.getElementById('routeInfo').style.display = 'block';
        }
        
        function displayRouteComparison(comparisonData) {
            clearRoute(false);
            
            // Display all routes
            Object.values(comparisonData.routes).forEach(routeInfo => {
                if (routeInfo.polylines) {
                    routeInfo.polylines.forEach(polyline => {
                        const mapPolyline = new google.maps.Polyline({
                            path: polyline.path,
                            geodesic: polyline.geodesic || true,
                            strokeColor: polyline.strokeColor,
                            strokeOpacity: polyline.strokeOpacity,
                            strokeWeight: polyline.strokeWeight,
                            map: map
                        });
                        
                        routePolylines.push(mapPolyline);
                    });
                }
            });
            
            // Show GPS HC2L metrics (look for base or disrupted route)
            const baseRoute = comparisonData.routes.base;
            const disruptedRoute = comparisonData.routes.disrupted;
            
            if (baseRoute && baseRoute.metrics) {
                showRouteMetrics(baseRoute.metrics);
            } else if (disruptedRoute && disruptedRoute.metrics) {
                showRouteMetrics(disruptedRoute.metrics);
            }
            
            // Show comparison details
            if (comparisonData.comparison) {
                showComparisonDetails(comparisonData);
            }
            
            // Fit map to show all routes
            const bounds = new google.maps.LatLngBounds();
            bounds.extend(comparisonData.start_point);
            bounds.extend(comparisonData.end_point);
            map.fitBounds(bounds);
            
            document.getElementById('routeLegend').style.display = 'block';
            document.getElementById('routeInfo').style.display = 'block';
        }
        
        function showComparisonDetails(comparisonData) {
            const detailsContainer = document.getElementById('routeDetails');
            
            const comparison = comparisonData.comparison;
            const routes = comparisonData.routes;
            
            let comparisonHTML = '<h4>üìä Route Comparison Analysis</h4>';
            
            if (comparison) {
                comparisonHTML += `
                    <div class="metrics-grid">
                        <div class="metric-box">
                            <div class="metric-value">${comparison.distance_difference_m.toFixed(0)}</div>
                            <div class="metric-label">Distance Difference (m)</div>
                        </div>
                        <div class="metric-box">
                            <div class="metric-value">${comparison.time_difference_ms.toFixed(1)}</div>
                            <div class="metric-label">Query Time Difference (ms)</div>
                        </div>
                    </div>
                `;
            }
            
            // Show details for each route
            Object.entries(routes).forEach(([routeName, routeInfo]) => {
                if (routeInfo.name && routeInfo.metrics) {
                    comparisonHTML += `
                        <div style="margin: 15px 0; padding: 10px; border-left: 4px solid ${routeInfo.color}; background: #f8f9fa;">
                            <h5>${routeInfo.name}</h5>
                            <p><strong>Distance:</strong> ${routeInfo.metrics.total_distance_m || 'N/A'} meters</p>
                            <p><strong>Query Time:</strong> ${routeInfo.metrics.query_time_ms || 'N/A'} ms</p>
                            <p><strong>Routing Mode:</strong> ${routeInfo.metrics.routing_mode || 'N/A'}</p>
                        </div>
                    `;
                }
            });
            
            detailsContainer.innerHTML = comparisonHTML;
        }
        
        function showRouteMetrics(metrics) {
            const metricsContainer = document.getElementById('routeMetrics');
            
            // Handle both old and new metric formats with safe defaults
            const queryTimeMs = metrics.query_time_ms || metrics.query_time_microseconds / 1000 || 0;
            const labelingSizeMb = metrics.labeling_size_mb || 0;
            const totalDistanceM = metrics.total_distance_m || metrics.total_distance_meters || 0;
            const estimatedTimeMin = metrics.estimated_time_min || metrics.estimated_time_minutes || 0;
            const numberOfNodes = metrics.number_of_nodes || metrics.path_length || 0;
            const usesDisruptions = metrics.uses_disruptions || false;
            
            const metricsHTML = `
                <div class="metric-box">
                    <div class="metric-value">${queryTimeMs.toFixed(1)}</div>
                    <div class="metric-label">Query Time (ms)</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">${labelingSizeMb.toFixed(2)}</div>
                    <div class="metric-label">Index Size (MB)</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">${totalDistanceM.toFixed(0)}</div>
                    <div class="metric-label">Distance (meters)</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">${estimatedTimeMin.toFixed(1)}</div>
                    <div class="metric-label">Est. Time (min)</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">${numberOfNodes}</div>
                    <div class="metric-label">Route Nodes</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">${usesDisruptions ? 'YES' : 'NO'}</div>
                    <div class="metric-label">Avoids Traffic</div>
                </div>
            `;
            
            metricsContainer.innerHTML = metricsHTML;
        }
        
        function showRouteDetails(routeData) {
            const detailsContainer = document.getElementById('routeDetails');
            
            // Build path information with road names if available
            let pathInfo = '';
            let roadSummary = '';
            let turnDirections = '';
            
            // Check if we have road segments with names
            if (routeData.route.road_segments && routeData.route.road_segments.length > 0) {
                // Display road segments with names
                routeData.route.road_segments.forEach((segment, index) => {
                    pathInfo += `<li>
                        <strong>Segment ${segment.segment_number}:</strong> 
                        ${segment.road_name} 
                        <span style="color: #666; font-size: 12px;">
                            (Node ${segment.from_node} ‚Üí ${segment.to_node})
                            ${segment.length_meters > 0 ? ` - ${segment.length_meters.toFixed(0)}m` : ''}
                        </span>
                    </li>`;
                });
                
                // Add route summary
                if (routeData.route.route_summary) {
                    roadSummary = `
                        <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #2196f3;">
                            <strong>üìç Route Summary:</strong> ${routeData.route.route_summary}
                        </div>
                    `;
                }
                
                // Add turn-by-turn directions
                if (routeData.route.turn_by_turn_directions && routeData.route.turn_by_turn_directions.length > 0) {
                    turnDirections = `
                        <div style="background: #f3e5f5; padding: 10px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #9c27b0;">
                            <strong>üß≠ Turn-by-Turn Directions:</strong>
                            <ol style="margin: 5px 0; padding-left: 20px;">
                    `;
                    
                    routeData.route.turn_by_turn_directions.forEach(direction => {
                        turnDirections += `<li style="margin: 3px 0;">${direction}</li>`;
                    });
                    
                    turnDirections += `</ol></div>`;
                }
                
            } else if (routeData.route.path_nodes && routeData.route.path_nodes.length > 0) {
                // Fallback: display node path
                const nodes = routeData.route.path_nodes;
                for (let i = 0; i < nodes.length - 1; i++) {
                    pathInfo += `<li>Step ${i + 1}: Node ${nodes[i]} ‚Üí Node ${nodes[i + 1]}</li>`;
                }
            } else {
                pathInfo = '<li>No detailed path information available</li>';
            }
            
            // Extract GPS mapping info if available
            let gpsInfo = '';
            if (routeData.gps_mapping) {
                gpsInfo = `
                    <div style="background: #e8f5e8; padding: 10px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #4caf50;">
                        <strong>üåç GPS Mapping:</strong> ${routeData.gps_mapping.gps_to_node_info}<br>
                        <strong>Start Node:</strong> ${routeData.gps_mapping.start_node}<br>
                        <strong>Destination Node:</strong> ${routeData.gps_mapping.dest_node}
                    </div>
                `;
            }
            
            const detailsHTML = `
                <h4>üõ£Ô∏è Route Path Details</h4>
                <p><strong>Algorithm:</strong> ${routeData.algorithm}</p>
                <p><strong>Total Computation Time:</strong> ${routeData.metrics.total_computation_time_sec || 'N/A'}s</p>
                
                ${gpsInfo}
                ${roadSummary}
                ${turnDirections}
                
                <details style="margin: 15px 0;">
                    <summary style="cursor: pointer; padding: 5px; background: #f5f5f5; border-radius: 3px;">
                        <strong>üìç Detailed Road Segments</strong>
                    </summary>
                    <ol style="max-height: 250px; overflow-y: auto; margin: 10px 0; padding-left: 20px;">
                        ${pathInfo}
                    </ol>
                </details>
                
                <details style="margin: 15px 0;">
                    <summary style="cursor: pointer; padding: 5px; background: #f5f5f5; border-radius: 3px;">
                        <strong>üîß Raw Algorithm Output</strong>
                    </summary>
                    <pre style="background: #f8f9fa; padding: 10px; border-radius: 5px; overflow-x: auto; font-size: 12px; margin: 10px 0;">
${routeData.raw_output || 'No raw output available'}
                    </pre>
                </details>
            `;
            
            detailsContainer.innerHTML = detailsHTML;
        }
        
        function clearRoute(clearMarkers = true) {
            // Clear polylines
            routePolylines.forEach(polyline => polyline.setMap(null));
            routePolylines = [];
            
            if (clearMarkers) {
                clearMarkers();
                
                // Reset state
                startCoords = null;
                endCoords = null;
                routeMode = false;
                pinStartMode = false;
                pinDestMode = false;
                
                // Disable buttons
                document.getElementById('computeBtn').disabled = true;
                document.getElementById('computeDisruptedBtn').disabled = true;
                document.getElementById('compareBtn').disabled = true;
                
                // Clear input fields
                document.getElementById('startLat').value = '';
                document.getElementById('startLng').value = '';
                document.getElementById('destLat').value = '';
                document.getElementById('destLng').value = '';
                
                // Reset instructions
                document.getElementById('instructionPanel').innerHTML = `
                    <strong>Instructions:</strong>
                    <ol>
                        <li>Click "Select Route Points" to enable point selection mode for both start and destination</li>
                        <li>OR use "üìç Pin Start Point" / "üìç Pin Destination" to set individual points</li>
                        <li>Click on the map to set your start point (green marker) and destination (red marker)</li>
                        <li>Coordinates will automatically fill in the manual input fields</li>
                        <li>Click "Compute D-HC2L Route" to find the optimal path</li>
                        <li>View routing metrics and performance data below</li>
                        <li>Use "Compare Routes" to see different routing approaches</li>
                    </ol>
                    <strong>Features:</strong> Real-time traffic awareness ‚Ä¢ Disruption avoidance ‚Ä¢ Performance metrics ‚Ä¢ Multi-algorithm comparison ‚Ä¢ Individual point pinning
                `;
            }
            
            // Hide route info
            document.getElementById('routeInfo').style.display = 'none';
            document.getElementById('routeLegend').style.display = 'none';
            
            // Clear error messages
            document.getElementById('errorContainer').innerHTML = '';
        }
        
        function clearMarkers() {
            if (startMarker) {
                startMarker.setMap(null);
                startMarker = null;
            }
            if (endMarker) {
                endMarker.setMap(null);
                endMarker = null;
            }
        }
        
        async function loadAllNodes() {
            try {
                const response = await fetch('/get_all_nodes');
                const result = await response.json();
                
                if (result.success) {
                    displayNodes(result.nodes);
                    console.log(`‚úÖ Loaded ${result.count} nodes`);
                } else {
                    showError('Error loading nodes: ' + result.error);
                }
            } catch (error) {
                showError('Network error: ' + error.message);
            }
        }
        
        function displayNodes(nodes) {
            // Clear existing nodes
            nodeMarkers.forEach(marker => marker.setMap(null));
            nodeMarkers = [];
            
            // Sample nodes to avoid overwhelming the map
            const sampleSize = Math.min(nodes.length, 500);
            const sampledNodes = nodes.sort(() => 0.5 - Math.random()).slice(0, sampleSize);
            
            sampledNodes.forEach(node => {
                const marker = new google.maps.Marker({
                    position: {lat: node.lat, lng: node.lng},
                    map: map,
                    title: `Node ${node.node_id}`,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 2,
                        fillColor: '#0000FF',
                        fillOpacity: 0.6,
                        strokeWeight: 1,
                        strokeColor: '#FFFFFF'
                    }
                });
                
                nodeMarkers.push(marker);
            });
            
            console.log(`Displayed ${sampledNodes.length} nodes on map`);
        }
        
        async function loadTrafficData() {
            try {
                const response = await fetch('/get_scenario_data');
                const result = await response.json();
                
                if (result.success) {
                    displayTrafficData(result.edges);
                    console.log(`‚úÖ Loaded traffic scenario: ${result.count} road segments`);
                } else {
                    showError('Error loading traffic data: ' + result.error);
                }
            } catch (error) {
                showError('Network error: ' + error.message);
            }
        }
        
        function displayTrafficData(edges) {
            // Clear existing traffic data
            trafficPolylines.forEach(polyline => polyline.setMap(null));
            trafficPolylines = [];
            
            edges.forEach(edge => {
                const path = [
                    {lat: edge.source_lat, lng: edge.source_lng},
                    {lat: edge.target_lat, lng: edge.target_lng}
                ];
                
                // Color based on traffic conditions
                let color, weight;
                if (edge.isClosed) {
                    color = '#FF0000';
                    weight = 4;
                } else if (edge.jamFactor > 7) {
                    color = '#FF4500';
                    weight = 3;
                } else if (edge.jamFactor > 4) {
                    color = '#FFA500';
                    weight = 3;
                } else if (edge.jamFactor > 2) {
                    color = '#FFFF00';
                    weight = 2;
                } else {
                    color = '#00FF00';
                    weight = 2;
                }
                
                const polyline = new google.maps.Polyline({
                    path: path,
                    geodesic: true,
                    strokeColor: color,
                    strokeOpacity: 0.7,
                    strokeWeight: weight,
                    map: map
                });
                
                trafficPolylines.push(polyline);
            });
        }
        
        function clearAll() {
            clearRoute(true);
            
            // Clear nodes
            nodeMarkers.forEach(marker => marker.setMap(null));
            nodeMarkers = [];
            
            // Clear traffic data
            trafficPolylines.forEach(polyline => polyline.setMap(null));
            trafficPolylines = [];
            
            // Reset all modes
            routeMode = false;
            pinStartMode = false;
            pinDestMode = false;
            
            map.setOptions({cursor: 'default'});
            console.log('All map data cleared');
        }
        
        function showLoading(show) {
            document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
        }
        
        function showError(message) {
            const container = document.getElementById('errorContainer');
            container.innerHTML = `<div class="error-message">‚ùå ${message}</div>`;
            console.error(message);
        }
    </script>
    
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA8oJEiJmkvcF04hG_SOTSAoav7puoM83Y&callback=initMap">
    </script>
</body>
</html>